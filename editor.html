<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Preview with Typewriter Effect</title>

  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #000920;
      font-family: "Fira Code", monospace;
      color: #fff;
    }

    #controls {
      background: #1a1a2e;
      padding: 10px 20px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .controls-group {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .speed-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .mode-controls {
      display: flex;
      gap: 10px;
    }

    .toggle-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    button {
      background: #16213e;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 10px 16px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid #333;
    }

    button:hover {
      background: #0f3460;
    }

    button.active {
      background: #4CAF50;
    }

    button.toggle-btn {
      background: #dc2626;
    }

    button.toggle-btn.active {
      background: #16a34a;
    }

    .speed-btn {
      padding: 8px 12px;
      font-size: 16px;
      font-weight: bold;
    }

    .speed-display {
      font-size: 14px;
      color: #fff;
      min-width: 80px;
      text-align: center;
    }

    /* Split panel container */
    #main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .split-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .panel-header {
      background: #16213e;
      padding: 8px 15px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-size: 14px;
      font-weight: bold;
      color: #4CAF50;
    }

    .panel-controls {
      display: flex;
      gap: 8px;
    }

    .panel-controls button {
      padding: 5px 10px;
      font-size: 12px;
    }

    .resizer {
      width: 5px;
      background: #333;
      cursor: col-resize;
      position: relative;
      transition: background 0.2s;
    }

    .resizer:hover {
      background: #4CAF50;
    }

    .resizer::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 2px;
      height: 40px;
      background: #666;
    }

    #editor, #output, #rendered, .panel-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      width: 100%;
      font-size: 1rem;
    }

    #editor {
      border: none;
      resize: none;
      outline: none;
      font-family: "Fira Code", monospace;
      background: #0d1117;
      color: #fff;
      display: block;
    }

    .panel-content {
      background: #0d1117;
    }

    pre {
      background: #0d1117 !important;
      border-radius: 10px;
      padding: 16px;
      color: #00ffcc !important;
      overflow-x: auto;
      margin: 10px 0;
    }

    code {
      font-family: "Fira Code", monospace;
      font-size: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .blinking-caret {
      border-right: 2px solid rgba(255, 255, 255, 0.8);
      animation: blink 0.8s infinite;
      display: inline-block;
    }

    @keyframes blink {
      0%, 100% { border-color: transparent; }
      50% { border-color: rgba(255, 255, 255, 0.8); }
    }

    #rendered, .panel-content.rendered-mode {
      background: #f9f9f9;
      color: #333;
    }

    .script-label {
      background: #2d2d2d;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px 5px 0 0;
      font-size: 0.85rem;
      margin-top: 15px;
      display: inline-block;
    }

    .style-label {
      background: #1e3a8a;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px 5px 0 0;
      font-size: 0.85rem;
      margin-top: 15px;
      display: inline-block;
    }

    #fullscreenBtn {
      margin-left: 10px;
    }

    /* Render container to isolate styles */
    #rendered-content, .rendered-html-content {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    /* Hide code blocks when toggled off */
    .code-block {
      transition: all 0.3s ease;
    }

    .code-block.hidden {
      display: none;
    }

    .separator {
      color: #999;
      margin: 0 5px;
    }

    .status-indicator {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 10px;
      background: #333;
      color: #fff;
      cursor: pointer;
      user-select: none;
    }

    .status-indicator:hover {
      opacity: 0.8;
    }

    .status-indicator.active {
      background: #16a34a;
    }

    .status-indicator.inactive {
      background: #dc2626;
    }

    /* Hide split view in edit mode */
    body.edit-mode #main-container {
      display: block;
    }

    body.edit-mode .split-panel:not(.left-panel) {
      display: none;
    }

    body.edit-mode .resizer {
      display: none;
    }

    body.edit-mode .left-panel {
      width: 100%;
    }

    /* Single panel mode */
    body.single-panel-mode .split-panel.right-panel,
    body.single-panel-mode .resizer {
      display: none;
    }

    body.single-panel-mode .split-panel.left-panel {
      width: 100%;
    }

    .pause-icon::before {
      content: '⏸';
    }

    button.paused .pause-icon::before {
      content: '▶';
    }
  </style>
</head>
<body class="edit-mode">
  <div id="controls">
    <div class="controls-group">
      <div class="speed-controls">
        <button class="speed-btn" id="decreaseSpeed">-</button>
        <div class="speed-display" id="speedDisplay">Speed: 20ms</div>
        <button class="speed-btn" id="increaseSpeed">+</button>
      </div>
    </div>

    <div class="controls-group">
      <div class="mode-controls">
        <button id="editModeBtn" class="active">Edit Mode</button>
        <button id="rawCodeBtn">Show Raw Code</button>
        <button id="renderModeBtn">Rendered HTML</button>
        <button id="fullscreenBtn">⛶ Fullscreen</button>
      </div>
    </div>

    <div class="controls-group">
      <div class="toggle-controls">
        <button id="pauseBtn" style="display: none;"><span class="pause-icon"></span> Pause</button>
        <button id="resetBtn" style="display: none;">↻ Reset</button>
        <button id="splitViewBtn">⚏ Split View</button>
        <span class="status-indicator" id="cssStatusIndicator">CSS: ON</span>
        <span class="status-indicator" id="jsStatusIndicator">JS: ON</span>
      </div>
    </div>
  </div>

  <div id="main-container">
    <!-- Left Panel -->
    <div class="split-panel left-panel">
      <div class="panel-header">
        <div class="panel-title">Left Panel</div>
      </div>
      <div class="panel-content left-content">
        <textarea id="editor" placeholder="Write HTML or JS code here..."></textarea>
      </div>
    </div>

    <!-- Resizer -->
    <div class="resizer" id="resizer"></div>

    <!-- Right Panel -->
    <div class="split-panel right-panel">
      <div class="panel-header">
        <div class="panel-title">Right Panel</div>
      </div>
      <div class="panel-content right-content">
        <textarea id="editorRight" placeholder="Write HTML or JS code here..."></textarea>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const editModeBtn = document.getElementById('editModeBtn');
    const rawCodeBtn = document.getElementById('rawCodeBtn');
    const renderModeBtn = document.getElementById('renderModeBtn');
    const decreaseSpeedBtn = document.getElementById('decreaseSpeed');
    const increaseSpeedBtn = document.getElementById('increaseSpeed');
    const speedDisplay = document.getElementById('speedDisplay');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const splitViewBtn = document.getElementById('splitViewBtn');
    const cssStatusIndicator = document.getElementById('cssStatusIndicator');
    const jsStatusIndicator = document.getElementById('jsStatusIndicator');
    const editor = document.getElementById('editor');
    const editorRight = document.getElementById('editorRight');
    const leftContent = document.querySelector('.left-content');
    const rightContent = document.querySelector('.right-content');
    const resizer = document.getElementById('resizer');
    const leftPanel = document.querySelector('.left-panel');
    const rightPanel = document.querySelector('.right-panel');

    // App State
    const appState = {
      mode: 'edit',
      splitViewEnabled: false,
      leftPanel: {
        index: 0,
        content: '',
        typingInterval: null,
        parsedSegments: [],
        extractedStyles: '',
        isPaused: false,
        isComplete: false
      },
      rightPanel: {
        index: 0,
        content: '',
        typingInterval: null,
        parsedSegments: [],
        extractedStyles: '',
        isPaused: false,
        isComplete: false
      },
      typingSpeed: 20,
      showCssCode: true,
      showJsCode: true
    };

    // Initialize the app
    function init() {
      setupEventListeners();
      updateActiveButton();
      updateStatusIndicators();
      loadDemoContent();
      setupResizer();
    }

    // Set up event listeners
    function setupEventListeners() {
      // Mode buttons
      editModeBtn.addEventListener('click', switchToEditMode);
      rawCodeBtn.addEventListener('click', switchToRawCodeMode);
      renderModeBtn.addEventListener('click', switchToRenderMode);
      
      // Speed controls
      decreaseSpeedBtn.addEventListener('click', decreaseSpeed);
      increaseSpeedBtn.addEventListener('click', increaseSpeed);
      
      // Fullscreen
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      document.addEventListener('fullscreenchange', updateFullscreenButton);
      
      // Pause and Reset
      pauseBtn.addEventListener('click', togglePause);
      resetBtn.addEventListener('click', resetTyping);
      
      // Split view
      splitViewBtn.addEventListener('click', toggleSplitView);
      
      // Toggle code visibility
      cssStatusIndicator.addEventListener('click', toggleCssCode);
      jsStatusIndicator.addEventListener('click', toggleJsCode);
    }

    // Setup resizer for split panel
    function setupResizer() {
      let isResizing = false;
      
      resizer.addEventListener('mousedown', function(e) {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;
        
        const container = document.getElementById('main-container');
        const containerRect = container.getBoundingClientRect();
        const leftWidth = ((e.clientX - containerRect.left) / containerRect.width) * 100;
        
        if (leftWidth > 20 && leftWidth < 80) {
          leftPanel.style.flex = leftWidth;
          rightPanel.style.flex = 100 - leftWidth;
        }
      });
      
      document.addEventListener('mouseup', function() {
        isResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      });
    }

    // Toggle split view
    function toggleSplitView() {
      appState.splitViewEnabled = !appState.splitViewEnabled;
      
      if (appState.splitViewEnabled) {
        document.body.classList.remove('single-panel-mode');
        splitViewBtn.textContent = '⚏ Single View';
        splitViewBtn.classList.add('active');
      } else {
        document.body.classList.add('single-panel-mode');
        splitViewBtn.textContent = '⚏ Split View';
        splitViewBtn.classList.remove('active');
      }
    }

    // Update active button state
    function updateActiveButton() {
      editModeBtn.classList.toggle('active', appState.mode === 'edit');
      rawCodeBtn.classList.toggle('active', appState.mode === 'raw');
      renderModeBtn.classList.toggle('active', appState.mode === 'render');
      
      // Show/hide pause and reset buttons
      const showControls = appState.mode !== 'edit';
      pauseBtn.style.display = showControls ? 'block' : 'none';
      resetBtn.style.display = showControls ? 'block' : 'none';
      
      // Update body class
      if (appState.mode === 'edit') {
        document.body.classList.add('edit-mode');
        document.body.classList.remove('single-panel-mode');
      } else {
        document.body.classList.remove('edit-mode');
        if (!appState.splitViewEnabled) {
          document.body.classList.add('single-panel-mode');
        }
      }
    }

    // Update status indicators
    function updateStatusIndicators() {
      cssStatusIndicator.textContent = `CSS: ${appState.showCssCode ? 'ON' : 'OFF'}`;
      cssStatusIndicator.className = `status-indicator ${appState.showCssCode ? 'active' : 'inactive'}`;
      
      jsStatusIndicator.textContent = `JS: ${appState.showJsCode ? 'ON' : 'OFF'}`;
      jsStatusIndicator.className = `status-indicator ${appState.showJsCode ? 'active' : 'inactive'}`;
      
      // Only show CSS/JS toggles in raw or render mode
      const showToggles = appState.mode === 'raw' || appState.mode === 'render';
      cssStatusIndicator.style.display = (showToggles && appState.mode === 'raw') ? 'inline-block' : 'none';
      jsStatusIndicator.style.display = showToggles ? 'inline-block' : 'none';
    }

    // Toggle pause/resume
    function togglePause() {
      if (appState.splitViewEnabled) {
        appState.leftPanel.isPaused = !appState.leftPanel.isPaused;
        appState.rightPanel.isPaused = !appState.rightPanel.isPaused;
      } else {
        appState.leftPanel.isPaused = !appState.leftPanel.isPaused;
      }
      
      pauseBtn.classList.toggle('paused', appState.leftPanel.isPaused);
      pauseBtn.innerHTML = appState.leftPanel.isPaused ? '<span class="pause-icon"></span> Resume' : '<span class="pause-icon"></span> Pause';
    }

    // Reset typing
    function resetTyping() {
      // Clear intervals
      clearInterval(appState.leftPanel.typingInterval);
      clearInterval(appState.rightPanel.typingInterval);
      
      // Reset state
      appState.leftPanel.index = 0;
      appState.leftPanel.isComplete = false;
      appState.leftPanel.isPaused = false;
      appState.rightPanel.index = 0;
      appState.rightPanel.isComplete = false;
      appState.rightPanel.isPaused = false;
      
      // Reset pause button
      pauseBtn.classList.remove('paused');
      pauseBtn.innerHTML = '<span class="pause-icon"></span> Pause';
      
      // Restart typing based on mode
      if (appState.mode === 'raw') {
        switchToRawCodeMode();
      } else if (appState.mode === 'render') {
        switchToRenderMode();
      }
    }

    // Encode HTML so tags show visibly
    function encodeHTML(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    // Typewriter effect for raw code
    function typeRawCode(panel, panelState, container) {
      if (panelState.isPaused) return;
      
      if (panelState.index < panelState.content.length) {
        const visibleText = encodeHTML(panelState.content.slice(0, panelState.index));
        container.innerHTML = '<pre><code class="language-markup">' + visibleText + '</code></pre><span class="blinking-caret"></span>';
        Prism.highlightAll();
        panelState.index++;
      } else {
        container.innerHTML = '<pre><code class="language-markup">' + encodeHTML(panelState.content) + '</code></pre>';
        Prism.highlightAll();
        clearInterval(panelState.typingInterval);
        panelState.isComplete = true;
      }
    }

    // Extract and separate style tags from HTML
    function extractStyles(html) {
      const stylePattern = /<style[^>]*>([\s\S]*?)<\/style>/gi;
      let styles = '';
      let match;
      
      while ((match = stylePattern.exec(html)) !== null) {
        styles += match[1] + '\n';
      }
      
      return styles;
    }

    // Parse HTML into segments (html, script, style)
    function parseHTMLIntoSegments(html) {
      const segments = [];
      const allMatches = [];
      
      // Find all script tags
      const scriptPattern = /<script[^>]*>([\s\S]*?)<\/script>/gi;
      let match;
      
      while ((match = scriptPattern.exec(html)) !== null) {
        allMatches.push({
          type: 'script',
          start: match.index,
          end: match.index + match[0].length,
          content: match[1].trim()
        });
      }
      
      // Find all style tags
      const stylePattern = /<style[^>]*>([\s\S]*?)<\/style>/gi;
      
      while ((match = stylePattern.exec(html)) !== null) {
        allMatches.push({
          type: 'style',
          start: match.index,
          end: match.index + match[0].length,
          content: match[1].trim()
        });
      }
      
      // Sort matches by position
      allMatches.sort((a, b) => a.start - b.start);
      
      let lastIndex = 0;
      
      for (let i = 0; i < allMatches.length; i++) {
        // Add HTML segment before current tag
        if (allMatches[i].start > lastIndex) {
          segments.push({
            type: 'html',
            content: html.substring(lastIndex, allMatches[i].start)
          });
        }
        
        // Add script or style segment
        segments.push({
          type: allMatches[i].type,
          content: allMatches[i].content
        });
        
        lastIndex = allMatches[i].end;
      }
      
      // Add remaining HTML
      if (lastIndex < html.length) {
        segments.push({
          type: 'html',
          content: html.substring(lastIndex)
        });
      }
      
      return segments;
    }

    // Build rendered output based on current character index
    function buildRenderedOutput(panelState, charIndex) {
      let htmlContent = '';
      let jsCodeBlocks = '';
      let cssCodeBlocks = '';
      let currentIndex = 0;
      
      for (let i = 0; i < panelState.parsedSegments.length; i++) {
        const segment = panelState.parsedSegments[i];
        const segmentLength = segment.content.length;
        
        if (currentIndex + segmentLength <= charIndex) {
          // This segment is fully typed
          if (segment.type === 'html') {
            htmlContent += segment.content;
          } else if (segment.type === 'script') {
            jsCodeBlocks += '<div class="code-block js-code-block' + (appState.showJsCode ? '' : ' hidden') + '">';
            jsCodeBlocks += '<div class="script-label">JavaScript Code:</div>';
            jsCodeBlocks += '<pre><code class="language-javascript">' + encodeHTML(segment.content) + '</code></pre>';
            jsCodeBlocks += '</div>';
          } else if (segment.type === 'style') {
            cssCodeBlocks += '<div class="code-block css-code-block' + (appState.showCssCode ? '' : ' hidden') + '">';
            cssCodeBlocks += '<div class="style-label">CSS Code:</div>';
            cssCodeBlocks += '<pre><code class="language-css">' + encodeHTML(segment.content) + '</code></pre>';
            cssCodeBlocks += '</div>';
          }
          currentIndex += segmentLength;
        } else {
          // This segment is partially typed
          const partialLength = charIndex - currentIndex;
          if (partialLength > 0) {
            if (segment.type === 'html') {
              htmlContent += segment.content.substring(0, partialLength);
            } else if (segment.type === 'script') {
              jsCodeBlocks += '<div class="code-block js-code-block' + (appState.showJsCode ? '' : ' hidden') + '">';
              jsCodeBlocks += '<div class="script-label">JavaScript Code:</div>';
              jsCodeBlocks += '<pre><code class="language-javascript">' + encodeHTML(segment.content.substring(0, partialLength)) + '</code></pre>';
              jsCodeBlocks += '</div>';
            } else if (segment.type === 'style') {
              cssCodeBlocks += '<div class="code-block css-code-block' + (appState.showCssCode ? '' : ' hidden') + '">';
              cssCodeBlocks += '<div class="style-label">CSS Code:</div>';
              cssCodeBlocks += '<pre><code class="language-css">' + encodeHTML(segment.content.substring(0, partialLength)) + '</code></pre>';
              cssCodeBlocks += '</div>';
            }
          }
          break;
        }
      }
      
      // In render mode: HTML first, then JS, then CSS
      let result = '';
      if (htmlContent) {
        result += '<div class="rendered-html-content">' + htmlContent + '</div>';
      }
      if (jsCodeBlocks) {
        result += jsCodeBlocks;
      }
      if (cssCodeBlocks) {
        result += cssCodeBlocks;
      }
      
      return result;
    }

    // Calculate total character count across all segments
    function getTotalCharCount(panelState) {
      let total = 0;
      for (let i = 0; i < panelState.parsedSegments.length; i++) {
        total += panelState.parsedSegments[i].content.length;
      }
      return total;
    }

    // Apply extracted styles to the rendered content
    function applyStyles(styles, panelId) {
      // Remove existing dynamic style tag if present
      const styleId = 'dynamic-styles-' + panelId;
      const existingStyle = document.getElementById(styleId);
      if (existingStyle) {
        existingStyle.remove();
      }
      
      if (styles) {
        const styleTag = document.createElement('style');
        styleTag.id = styleId;
        styleTag.textContent = styles;
        document.head.appendChild(styleTag);
      }
    }

    // Typewriter effect for rendered HTML
    function typeRenderedHTML(panel, panelState, container, panelId) {
      if (panelState.isPaused) return;
      
      const totalChars = getTotalCharCount(panelState);
      
      if (panelState.index < totalChars) {
        const output = buildRenderedOutput(panelState, panelState.index);
        container.innerHTML = output + '<span class="blinking-caret"></span>';
        
        // Apply styles
        applyStyles(panelState.extractedStyles, panelId);
        
        setTimeout(function() {
          Prism.highlightAll();
        }, 0);
        
        panelState.index++;
      } else {
        const output = buildRenderedOutput(panelState, totalChars);
        container.innerHTML = output;
        
        // Apply styles
        applyStyles(panelState.extractedStyles, panelId);
        
        setTimeout(function() {
          Prism.highlightAll();
        }, 0);
        
        clearInterval(panelState.typingInterval);
        panelState.isComplete = true;
      }
    }

    // Toggle CSS Code visibility
    function toggleCssCode() {
      appState.showCssCode = !appState.showCssCode;
      updateStatusIndicators();
      
      // Update rendered output if in render or raw mode
      if (appState.mode === 'render') {
        const cssBlocks = document.querySelectorAll('.css-code-block');
        cssBlocks.forEach(function(block) {
          block.classList.toggle('hidden', !appState.showCssCode);
        });
      } else if (appState.mode === 'raw') {
        // In raw mode, CSS toggle should hide/show CSS code
        // Re-render the content
        updateRawCodeDisplay();
      }
    }

    // Toggle JavaScript Code visibility
    function toggleJsCode() {
      appState.showJsCode = !appState.showJsCode;
      updateStatusIndicators();
      
      // Update rendered output if in render mode
      if (appState.mode === 'render') {
        const jsBlocks = document.querySelectorAll('.js-code-block');
        jsBlocks.forEach(function(block) {
          block.classList.toggle('hidden', !appState.showJsCode);
        });
      }
    }

    // Update raw code display with CSS toggle
    function updateRawCodeDisplay() {
      // Left panel
      if (appState.leftPanel.isComplete) {
        const filteredContent = filterRawCode(appState.leftPanel.content);
        leftContent.innerHTML = '<pre><code class="language-markup">' + encodeHTML(filteredContent) + '</code></pre>';
        Prism.highlightAll();
      }
      
      // Right panel
      if (appState.splitViewEnabled && appState.rightPanel.isComplete) {
        const filteredContent = filterRawCode(appState.rightPanel.content);
        rightContent.innerHTML = '<pre><code class="language-markup">' + encodeHTML(filteredContent) + '</code></pre>';
        Prism.highlightAll();
      }
    }

    // Filter raw code based on CSS visibility
    function filterRawCode(content) {
      if (appState.showCssCode) {
        return content;
      }
      
      // Remove CSS style tags
      return content.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
    }

    // Fullscreen Toggle
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(function() {
          fullscreenBtn.textContent = '⛶ Exit Fullscreen';
        }).catch(function(err) {
          console.error('Error attempting to enable fullscreen:', err);
        });
      } else {
        document.exitFullscreen().then(function() {
          fullscreenBtn.textContent = '⛶ Fullscreen';
        });
      }
    }

    // Update fullscreen button text
    function updateFullscreenButton() {
      if (!document.fullscreenElement) {
        fullscreenBtn.textContent = '⛶ Fullscreen';
      } else {
        fullscreenBtn.textContent = '⛶ Exit Fullscreen';
      }
    }

    // Edit Mode
    function switchToEditMode() {
      clearInterval(appState.leftPanel.typingInterval);
      clearInterval(appState.rightPanel.typingInterval);
      
      appState.mode = 'edit';
      
      // Show editors
      editor.style.display = 'block';
      editorRight.style.display = 'block';
      
      // Clear content areas
      leftContent.innerHTML = '';
      rightContent.innerHTML = '';
      leftContent.appendChild(editor);
      rightContent.appendChild(editorRight);
      
      // Remove dynamic styles
      removeDynamicStyles();
      
      updateActiveButton();
      updateStatusIndicators();
    }

    // Show Raw Code with typing effect
    function switchToRawCodeMode() {
      clearInterval(appState.leftPanel.typingInterval);
      clearInterval(appState.rightPanel.typingInterval);
      
      appState.mode = 'raw';
      
      // If typing was complete, preserve it
      if (!appState.leftPanel.isComplete) {
        appState.leftPanel.content = editor.value;
        appState.leftPanel.index = 0;
      }
      
      if (appState.splitViewEnabled && !appState.rightPanel.isComplete) {
        appState.rightPanel.content = editorRight.value;
        appState.rightPanel.index = 0;
      }
      
      // Hide editors
      editor.style.display = 'none';
      editorRight.style.display = 'none';
      
      // Clear and setup left panel
      leftContent.innerHTML = '';
      leftContent.classList.remove('rendered-mode');
      
      if (appState.leftPanel.isComplete) {
        // Show completed content immediately
        const filteredContent = filterRawCode(appState.leftPanel.content);
        leftContent.innerHTML = '<pre><code class="language-markup">' + encodeHTML(filteredContent) + '</code></pre>';
        Prism.highlightAll();
      } else {
        // Start typing
        appState.leftPanel.typingInterval = setInterval(function() {
          typeRawCode('left', appState.leftPanel, leftContent);
        }, appState.typingSpeed);
      }
      
      // Setup right panel if split view
      if (appState.splitViewEnabled) {
        rightContent.innerHTML = '';
        rightContent.classList.remove('rendered-mode');
        
        if (appState.rightPanel.isComplete) {
          const filteredContent = filterRawCode(appState.rightPanel.content);
          rightContent.innerHTML = '<pre><code class="language-markup">' + encodeHTML(filteredContent) + '</code></pre>';
          Prism.highlightAll();
        } else {
          appState.rightPanel.typingInterval = setInterval(function() {
            typeRawCode('right', appState.rightPanel, rightContent);
          }, appState.typingSpeed);
        }
      }
      
      // Remove dynamic styles when leaving render mode
      removeDynamicStyles();
      
      updateActiveButton();
      updateStatusIndicators();
    }

    // Rendered HTML Mode with typing effect
    function switchToRenderMode() {
      clearInterval(appState.leftPanel.typingInterval);
      clearInterval(appState.rightPanel.typingInterval);
      
      appState.mode = 'render';
      
      // If typing was complete, preserve it
      if (!appState.leftPanel.isComplete) {
        appState.leftPanel.content = editor.value;
        appState.leftPanel.extractedStyles = extractStyles(appState.leftPanel.content);
        appState.leftPanel.parsedSegments = parseHTMLIntoSegments(appState.leftPanel.content);
        appState.leftPanel.index = 0;
      }
      
      if (appState.splitViewEnabled && !appState.rightPanel.isComplete) {
        appState.rightPanel.content = editorRight.value;
        appState.rightPanel.extractedStyles = extractStyles(appState.rightPanel.content);
        appState.rightPanel.parsedSegments = parseHTMLIntoSegments(appState.rightPanel.content);
        appState.rightPanel.index = 0;
      }
      
      // Hide editors
      editor.style.display = 'none';
      editorRight.style.display = 'none';
      
      // Clear and setup left panel
      leftContent.innerHTML = '';
      leftContent.classList.add('rendered-mode');
      
      if (appState.leftPanel.isComplete) {
        // Show completed content immediately
        const totalChars = getTotalCharCount(appState.leftPanel);
        const output = buildRenderedOutput(appState.leftPanel, totalChars);
        leftContent.innerHTML = output;
        applyStyles(appState.leftPanel.extractedStyles, 'left');
        Prism.highlightAll();
      } else {
        // Start typing
        appState.leftPanel.typingInterval = setInterval(function() {
          typeRenderedHTML('left', appState.leftPanel, leftContent, 'left');
        }, appState.typingSpeed);
      }
      
      // Setup right panel if split view
      if (appState.splitViewEnabled) {
        rightContent.innerHTML = '';
        rightContent.classList.add('rendered-mode');
        
        if (appState.rightPanel.isComplete) {
          const totalChars = getTotalCharCount(appState.rightPanel);
          const output = buildRenderedOutput(appState.rightPanel, totalChars);
          rightContent.innerHTML = output;
          applyStyles(appState.rightPanel.extractedStyles, 'right');
          Prism.highlightAll();
        } else {
          appState.rightPanel.typingInterval = setInterval(function() {
            typeRenderedHTML('right', appState.rightPanel, rightContent, 'right');
          }, appState.typingSpeed);
        }
      }
      
      updateActiveButton();
      updateStatusIndicators();
    }

    // Remove all dynamic styles
    function removeDynamicStyles() {
      const leftStyle = document.getElementById('dynamic-styles-left');
      const rightStyle = document.getElementById('dynamic-styles-right');
      if (leftStyle) leftStyle.remove();
      if (rightStyle) rightStyle.remove();
    }

    // Decrease typing speed (increase delay)
    function decreaseSpeed() {
      appState.typingSpeed = Math.min(appState.typingSpeed + 10, 200);
      updateSpeedDisplay();
      
      // Restart intervals with new speed
      if (appState.mode === 'raw' || appState.mode === 'render') {
        clearInterval(appState.leftPanel.typingInterval);
        clearInterval(appState.rightPanel.typingInterval);
        
        if (!appState.leftPanel.isComplete) {
          if (appState.mode === 'raw') {
            appState.leftPanel.typingInterval = setInterval(function() {
              typeRawCode('left', appState.leftPanel, leftContent);
            }, appState.typingSpeed);
          } else {
            appState.leftPanel.typingInterval = setInterval(function() {
              typeRenderedHTML('left', appState.leftPanel, leftContent, 'left');
            }, appState.typingSpeed);
          }
        }
        
        if (appState.splitViewEnabled && !appState.rightPanel.isComplete) {
          if (appState.mode === 'raw') {
            appState.rightPanel.typingInterval = setInterval(function() {
              typeRawCode('right', appState.rightPanel, rightContent);
            }, appState.typingSpeed);
          } else {
            appState.rightPanel.typingInterval = setInterval(function() {
              typeRenderedHTML('right', appState.rightPanel, rightContent, 'right');
            }, appState.typingSpeed);
          }
        }
      }
    }

    // Increase typing speed (decrease delay)
    function increaseSpeed() {
      appState.typingSpeed = Math.max(appState.typingSpeed - 10, 10);
      updateSpeedDisplay();
      
      // Restart intervals with new speed
      if (appState.mode === 'raw' || appState.mode === 'render') {
        clearInterval(appState.leftPanel.typingInterval);
        clearInterval(appState.rightPanel.typingInterval);
        
        if (!appState.leftPanel.isComplete) {
          if (appState.mode === 'raw') {
            appState.leftPanel.typingInterval = setInterval(function() {
              typeRawCode('left', appState.leftPanel, leftContent);
            }, appState.typingSpeed);
          } else {
            appState.leftPanel.typingInterval = setInterval(function() {
              typeRenderedHTML('left', appState.leftPanel, leftContent, 'left');
            }, appState.typingSpeed);
          }
        }
        
        if (appState.splitViewEnabled && !appState.rightPanel.isComplete) {
          if (appState.mode === 'raw') {
            appState.rightPanel.typingInterval = setInterval(function() {
              typeRawCode('right', appState.rightPanel, rightContent);
            }, appState.typingSpeed);
          } else {
            appState.rightPanel.typingInterval = setInterval(function() {
              typeRenderedHTML('right', appState.rightPanel, rightContent, 'right');
            }, appState.typingSpeed);
          }
        }
      }
    }

    // Update speed display
    function updateSpeedDisplay() {
      speedDisplay.textContent = 'Speed: ' + appState.typingSpeed + 'ms';
    }

    // Load demo content
    function loadDemoContent() {
      const demoCode = `<style>
.card {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 30px;
  border-radius: 15px;
  color: white;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  max-width: 400px;
  margin: 20px auto;
}

.card h1 {
  margin: 0 0 15px 0;
  font-size: 2em;
}

.card p {
  font-size: 1.1em;
  line-height: 1.6;
}

.btn {
  background: white;
  color: #667eea;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s;
}

.btn:hover {
  transform: scale(1.05);
}
</style>

<div class="card">
  <h1>Hello JavaScript</h1>
  <p>Welcome to this interactive tutorial with styles and classes!</p>
  <button id="button" class="btn">Click Me!</button>
</div>

<script>
const btn = document.getElementById("button");
if (btn) {
  btn.addEventListener("click", () => {
    alert("Button clicked!");
  });
}
<\/script>`;

      editor.value = demoCode;
      
      // Load different demo for right panel
      const demoCode2 = `<style>
.info-box {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  padding: 25px;
  border-radius: 12px;
  color: white;
  box-shadow: 0 8px 25px rgba(0,0,0,0.2);
  max-width: 350px;
  margin: 20px auto;
}

.info-box h2 {
  margin: 0 0 10px 0;
  font-size: 1.8em;
}

.info-box p {
  font-size: 1em;
  line-height: 1.5;
}
</style>

<div class="info-box">
  <h2>Comparison Panel</h2>
  <p>This is a different code example for comparison!</p>
</div>

<script>
console.log("Right panel loaded!");
<\/script>`;
      
      editorRight.value = demoCode2;
    }

    // Initialize the application
    init();
  </script>
</body>
</html>