<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Helpers Reactive - Test Suite</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }
    
    .test-summary {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .test-summary h2 {
      margin-top: 0;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    
    .stat {
      padding: 15px;
      border-radius: 6px;
      text-align: center;
    }
    
    .stat.passed {
      background: #e8f5e9;
      color: #2e7d32;
    }
    
    .stat.failed {
      background: #ffebee;
      color: #c62828;
    }
    
    .stat.total {
      background: #e3f2fd;
      color: #1565c0;
    }
    
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      display: block;
    }
    
    .stat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }
    
    .test-group {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .test-group h3 {
      margin-top: 0;
      color: #555;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    
    .test-case {
      padding: 12px;
      margin: 8px 0;
      border-radius: 6px;
      border-left: 4px solid;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .test-case.passed {
      background: #f1f8f4;
      border-color: #4CAF50;
    }
    
    .test-case.failed {
      background: #fef5f5;
      border-color: #f44336;
    }
    
    .test-name {
      flex: 1;
      font-weight: 500;
    }
    
    .test-status {
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 0.85em;
      font-weight: bold;
      margin-left: 10px;
    }
    
    .test-status.passed {
      background: #4CAF50;
      color: white;
    }
    
    .test-status.failed {
      background: #f44336;
      color: white;
    }
    
    .test-duration {
      color: #999;
      font-size: 0.85em;
      margin-left: 10px;
    }
    
    .test-error {
      margin-top: 8px;
      padding: 10px;
      background: #fff3cd;
      border-left: 3px solid #ff9800;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .progress-bar {
      width: 100%;
      height: 30px;
      background: #e0e0e0;
      border-radius: 15px;
      overflow: hidden;
      margin: 20px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 0.9em;
    }
    
    .run-tests-btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 1em;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.3s ease;
    }
    
    .run-tests-btn:hover {
      background: #45a049;
    }
    
    .run-tests-btn:active {
      transform: translateY(1px);
    }
    
    .run-tests-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    #test-container {
      display: none;
    }
    
    .show-tests {
      display: block !important;
    }
  </style>
</head>
<body>
  <h1>🧪 DOM Helpers Reactive - Test Suite</h1>
  
  <div class="test-summary">
    <h2>Test Summary</h2>
    <button class="run-tests-btn" onclick="runAllTests()">Run All Tests</button>
    
    <div class="progress-bar" id="progress-bar" style="display: none;">
      <div class="progress-fill" id="progress-fill">0%</div>
    </div>
    
    <div class="stats">
      <div class="stat total">
        <span class="stat-value" id="total-tests">0</span>
        <span class="stat-label">Total Tests</span>
      </div>
      <div class="stat passed">
        <span class="stat-value" id="passed-tests">0</span>
        <span class="stat-label">Passed</span>
      </div>
      <div class="stat failed">
        <span class="stat-value" id="failed-tests">0</span>
        <span class="stat-label">Failed</span>
      </div>
    </div>
  </div>
  
  <div id="test-container"></div>

  <!-- Mock DOM Helpers Core (minimal implementation for testing) -->
  <script>
    // Mock Elements API
    window.Elements = {
      get: function(id) {
        return document.getElementById(id);
      }
    };

    // Mock Collections API
    window.Collections = {
      get: function(className) {
        return Array.from(document.getElementsByClassName(className));
      }
    };

    // Mock Selector API
    window.Selector = {
      query: function(selector) {
        return document.querySelector(selector);
      },
      queryAll: function(selector) {
        return Array.from(document.querySelectorAll(selector));
      }
    };
  </script>

  <!-- Load the Reactive Module -->
   <script src="../../src/dom-helpers.js"></script>
  <script src="../../src/dom-helpers-reactive.js"></script>

  <!-- Test Suite Implementation -->
  <script>
    // Simple Test Framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.results = {
          total: 0,
          passed: 0,
          failed: 0
        };
        this.currentGroup = null;
      }

      describe(name, fn) {
        this.currentGroup = {
          name,
          tests: []
        };
        fn();
        this.tests.push(this.currentGroup);
        this.currentGroup = null;
      }

      it(name, fn) {
        if (!this.currentGroup) {
          throw new Error('it() must be called within describe()');
        }
        this.currentGroup.tests.push({ name, fn });
      }

      async runAll() {
        this.results = { total: 0, passed: 0, failed: 0 };
        const container = document.getElementById('test-container');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        
        container.innerHTML = '';
        container.classList.add('show-tests');
        progressBar.style.display = 'block';
        
        // Count total tests
        const totalTests = this.tests.reduce((sum, group) => sum + group.tests.length, 0);
        let completedTests = 0;

        for (const group of this.tests) {
          const groupEl = document.createElement('div');
          groupEl.className = 'test-group';
          groupEl.innerHTML = `<h3>${group.name}</h3>`;
          container.appendChild(groupEl);

          for (const test of group.tests) {
            this.results.total++;
            const testEl = document.createElement('div');
            testEl.className = 'test-case';
            
            const startTime = performance.now();
            let passed = false;
            let error = null;

            try {
              await test.fn();
              passed = true;
              this.results.passed++;
            } catch (e) {
              passed = false;
              error = e;
              this.results.failed++;
            }

            const duration = (performance.now() - startTime).toFixed(2);
            
            testEl.className = `test-case ${passed ? 'passed' : 'failed'}`;
            testEl.innerHTML = `
              <div class="test-name">${test.name}</div>
              <div class="test-duration">${duration}ms</div>
              <div class="test-status ${passed ? 'passed' : 'failed'}">${passed ? '✓ PASS' : '✗ FAIL'}</div>
            `;

            if (error) {
              const errorEl = document.createElement('div');
              errorEl.className = 'test-error';
              errorEl.textContent = error.stack || error.message || String(error);
              testEl.appendChild(errorEl);
            }

            groupEl.appendChild(testEl);
            
            completedTests++;
            const progress = (completedTests / totalTests) * 100;
            progressFill.style.width = progress + '%';
            progressFill.textContent = Math.round(progress) + '%';
            
            // Allow UI to update
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        this.updateSummary();
        progressBar.style.display = 'none';
      }

      updateSummary() {
        document.getElementById('total-tests').textContent = this.results.total;
        document.getElementById('passed-tests').textContent = this.results.passed;
        document.getElementById('failed-tests').textContent = this.results.failed;
      }
    }

    // Assertion helpers
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, but got ${actual}`);
      }
    }

    function assertDeepEqual(actual, expected, message) {
      const actualStr = JSON.stringify(actual);
      const expectedStr = JSON.stringify(expected);
      if (actualStr !== expectedStr) {
        throw new Error(message || `Expected ${expectedStr}, but got ${actualStr}`);
      }
    }

    function assertThrows(fn, message) {
      let threw = false;
      try {
        fn();
      } catch (e) {
        threw = true;
      }
      if (!threw) {
        throw new Error(message || 'Expected function to throw');
      }
    }

    async function waitFor(condition, timeout = 1000, interval = 10) {
      const startTime = Date.now();
      while (Date.now() - startTime < timeout) {
        if (await condition()) {
          return;
        }
        await new Promise(resolve => setTimeout(resolve, interval));
      }
      throw new Error('Timeout waiting for condition');
    }

    // Helper to create test elements
    function createTestElement(id, tagName = 'div') {
      const el = document.createElement(tagName);
      el.id = id;
      document.body.appendChild(el);
      return el;
    }

    function removeTestElement(id) {
      const el = document.getElementById(id);
      if (el) el.remove();
    }

    // Create test runner
    const runner = new TestRunner();

    // ===== TEST SUITES =====

    // 1. Basic Reactivity Tests
    runner.describe('Basic Reactivity', () => {
      runner.it('should create reactive state', () => {
        const state = ReactiveState.create({ count: 0 });
        assert(ReactiveState.isReactive(state), 'State should be reactive');
        assertEqual(state.count, 0);
      });

      runner.it('should update reactive properties', () => {
        const state = ReactiveState.create({ count: 0 });
        state.count = 5;
        assertEqual(state.count, 5);
      });

      runner.it('should handle nested objects', () => {
        const state = ReactiveState.create({
          user: { name: 'John', age: 30 }
        });
        assert(ReactiveState.isReactive(state.user), 'Nested object should be reactive');
        state.user.name = 'Jane';
        assertEqual(state.user.name, 'Jane');
      });

      runner.it('should handle arrays', () => {
        const state = ReactiveState.create({ items: [1, 2, 3] });
        assert(ReactiveState.isReactive(state.items), 'Array should be reactive');
        state.items.push(4);
        assertEqual(state.items.length, 4);
      });

      runner.it('should return raw values with toRaw()', () => {
        const original = { count: 0 };
        const state = ReactiveState.create(original);
        const raw = ReactiveState.toRaw(state);
        assertEqual(raw.count, 0);
        assert(!ReactiveState.isReactive(raw), 'Raw value should not be reactive');
      });

      runner.it('should access raw values with $raw', () => {
        const state = ReactiveState.create({ count: 0 });
        const raw = state.$raw;
        assert(!ReactiveState.isReactive(raw), 'Raw value should not be reactive');
      });
    });

    // 2. DOM Binding Tests
    runner.describe('DOM Bindings', () => {
      runner.it('should bind to element by ID', async () => {
        const el = createTestElement('test-bind-1');
        const state = ReactiveState.create({ message: 'Hello' });

        Elements.bind({
          'test-bind-1': () => state.message
        });

        await waitFor(() => el.textContent === 'Hello');
        assertEqual(el.textContent, 'Hello');

        state.message = 'World';
        await waitFor(() => el.textContent === 'World');
        assertEqual(el.textContent, 'World');

        Elements.unbind('test-bind-1');
        removeTestElement('test-bind-1');
      });

      runner.it('should bind to specific property', async () => {
        const el = createTestElement('test-bind-2', 'input');
        const state = ReactiveState.create({ value: 'test' });

        Elements.bind({
          'test-bind-2': {
            value: () => state.value
          }
        });

        await waitFor(() => el.value === 'test');
        assertEqual(el.value, 'test');

        state.value = 'updated';
        await waitFor(() => el.value === 'updated');
        assertEqual(el.value, 'updated');

        Elements.unbind('test-bind-2');
        removeTestElement('test-bind-2');
      });

      runner.it('should bind to multiple elements by class', async () => {
        const el1 = createTestElement('test-class-1');
        const el2 = createTestElement('test-class-2');
        el1.className = 'test-class';
        el2.className = 'test-class';

        const state = ReactiveState.create({ text: 'Shared' });

        Collections.bind({
          'test-class': () => state.text
        });

        await waitFor(() => el1.textContent === 'Shared' && el2.textContent === 'Shared');
        assertEqual(el1.textContent, 'Shared');
        assertEqual(el2.textContent, 'Shared');

        state.text = 'Updated';
        await waitFor(() => el1.textContent === 'Updated' && el2.textContent === 'Updated');
        assertEqual(el1.textContent, 'Updated');
        assertEqual(el2.textContent, 'Updated');

        Collections.unbind('test-class');
        removeTestElement('test-class-1');
        removeTestElement('test-class-2');
      });

      runner.it('should handle style bindings', async () => {
        const el = createTestElement('test-style');
        const state = ReactiveState.create({ color: 'red' });

        Elements.bind({
          'test-style': {
            style: () => ({ color: state.color })
          }
        });

        await waitFor(() => el.style.color === 'red');
        assertEqual(el.style.color, 'red');

        state.color = 'blue';
        await waitFor(() => el.style.color === 'blue');
        assertEqual(el.style.color, 'blue');

        Elements.unbind('test-style');
        removeTestElement('test-style');
      });

      runner.it('should handle classList bindings', async () => {
        const el = createTestElement('test-classList');
        const state = ReactiveState.create({ active: true });

        Elements.bind({
          'test-classList': {
            classList: () => ({ active: state.active, inactive: !state.active })
          }
        });

        await waitFor(() => el.classList.contains('active'));
        assert(el.classList.contains('active'));
        assert(!el.classList.contains('inactive'));

        state.active = false;
        await waitFor(() => el.classList.contains('inactive'));
        assert(!el.classList.contains('active'));
        assert(el.classList.contains('inactive'));

        Elements.unbind('test-classList');
        removeTestElement('test-classList');
      });
    });

    // 3. Computed Properties Tests
    runner.describe('Computed Properties', () => {
      runner.it('should create computed properties', () => {
        const state = ReactiveState.create({ firstName: 'John', lastName: 'Doe' });
        
        state.$computed('fullName', function() {
          return `${this.firstName} ${this.lastName}`;
        });

        assertEqual(state.fullName, 'John Doe');
      });

      runner.it('should update computed properties when dependencies change', () => {
        const state = ReactiveState.create({ a: 1, b: 2 });
        
        state.$computed('sum', function() {
          return this.a + this.b;
        });

        assertEqual(state.sum, 3);

        state.a = 5;
        assertEqual(state.sum, 7);

        state.b = 10;
        assertEqual(state.sum, 15);
      });

      runner.it('should cache computed values', () => {
        let callCount = 0;
        const state = ReactiveState.create({ value: 1 });
        
        state.$computed('doubled', function() {
          callCount++;
          return this.value * 2;
        });

        const result1 = state.doubled;
        const result2 = state.doubled;
        const result3 = state.doubled;

        assertEqual(result1, 2);
        assertEqual(callCount, 1, 'Computed should only be called once');
      });

      runner.it('should invalidate cache when dependencies change', () => {
        let callCount = 0;
        const state = ReactiveState.create({ value: 1 });
        
        state.$computed('doubled', function() {
          callCount++;
          return this.value * 2;
        });

        state.doubled; // First access
        assertEqual(callCount, 1);

        state.value = 2; // Invalidate cache
        state.doubled; // Second access
        assertEqual(callCount, 2);
      });

      runner.it('should handle nested computed properties', () => {
        const state = ReactiveState.create({ value: 10 });
        
        state.$computed('doubled', function() {
          return this.value * 2;
        });

        state.$computed('quadrupled', function() {
          return this.doubled * 2;
        });

        assertEqual(state.quadrupled, 40);

        state.value = 5;
        assertEqual(state.quadrupled, 20);
      });
    });

    // 4. Batch Updates Tests
    runner.describe('Batch Updates', () => {
      runner.it('should batch multiple updates', async () => {
        const el = createTestElement('test-batch');
        const state = ReactiveState.create({ count: 0 });
        let updateCount = 0;

        Elements.bind({
          'test-batch': () => {
            updateCount++;
            return state.count;
          }
        });

        await waitFor(() => el.textContent === '0');
        const initialCount = updateCount;

        ReactiveState.batch(() => {
          state.count = 1;
          state.count = 2;
          state.count = 3;
        });

        await waitFor(() => el.textContent === '3');
        assertEqual(el.textContent, '3');
        
        // Should have updated only once more (batched)
        assert(updateCount <= initialCount + 2, 'Should batch updates');

        Elements.unbind('test-batch');
        removeTestElement('test-batch');
      });

      runner.it('should support nested batching', async () => {
        const el = createTestElement('test-nested-batch');
        const state = ReactiveState.create({ value: 0 });
        let updateCount = 0;

        Elements.bind({
          'test-nested-batch': () => {
            updateCount++;
            return state.value;
          }
        });

        await waitFor(() => el.textContent === '0');
        const initialCount = updateCount;

        ReactiveState.batch(() => {
          state.value = 1;
          ReactiveState.batch(() => {
            state.value = 2;
            state.value = 3;
          });
          state.value = 4;
        });

        await waitFor(() => el.textContent === '4');
        assert(updateCount <= initialCount + 2, 'Should batch nested updates');

        Elements.unbind('test-nested-batch');
        removeTestElement('test-nested-batch');
      });

      runner.it('should support $batch method', async () => {
        const el = createTestElement('test-batch-method');
        const state = ReactiveState.create({ x: 0, y: 0 });

        Elements.bind({
          'test-batch-method': () => `${state.x},${state.y}`
        });

        await waitFor(() => el.textContent === '0,0');

        state.$batch(function() {
          this.x = 10;
          this.y = 20;
        });

        await waitFor(() => el.textContent === '10,20');
        assertEqual(el.textContent, '10,20');

        Elements.unbind('test-batch-method');
        removeTestElement('test-batch-method');
      });
    });

    // 5. Watch Tests
    runner.describe('Watchers', () => {
      runner.it('should watch property changes', async () => {
        const state = ReactiveState.create({ count: 0 });
        let watchedValue = null;
        let oldValue = null;

        const unwatch = state.$watch('count', (newVal, oldVal) => {
          watchedValue = newVal;
          oldValue = oldVal;
        });

        state.count = 5;
        await waitFor(() => watchedValue === 5);
        assertEqual(watchedValue, 5);
        assertEqual(oldValue, 0);

        state.count = 10;
        await waitFor(() => watchedValue === 10);
        assertEqual(watchedValue, 10);
        assertEqual(oldValue, 5);

        unwatch();
      });

      runner.it('should watch computed values', async () => {
        const state = ReactiveState.create({ a: 1, b: 2 });
        let watchedSum = null;

        const unwatch = state.$watch(
          function() { return this.a + this.b; },
          (newVal) => { watchedSum = newVal; }
        );

        state.a = 5;
        await waitFor(() => watchedSum === 7);
        assertEqual(watchedSum, 7);

        state.b = 10;
        await waitFor(() => watchedSum === 15);
        assertEqual(watchedSum, 15);

        unwatch();
      });

      runner.it('should stop watching when unwatch is called', async () => {
        const state = ReactiveState.create({ value: 0 });
        let callCount = 0;

        const unwatch = state.$watch('value', () => {
          callCount++;
        });

        state.value = 1;
        await waitFor(() => callCount === 1);

        unwatch();

        state.value = 2;
        await new Promise(resolve => setTimeout(resolve, 50));
        
        assertEqual(callCount, 1, 'Watcher should not be called after unwatch');
      });
    });

    // 6. Array Reactivity Tests
    runner.describe('Array Reactivity', () => {
      runner.it('should react to push()', async () => {
        const el = createTestElement('test-array-push');
        const state = ReactiveState.create({ items: [1, 2] });

        Elements.bind({
          'test-array-push': () => state.items.join(',')
        });

        await waitFor(() => el.textContent === '1,2');

        state.items.push(3);
        await waitFor(() => el.textContent === '1,2,3');
        assertEqual(el.textContent, '1,2,3');

        Elements.unbind('test-array-push');
        removeTestElement('test-array-push');
      });

      runner.it('should react to pop()', async () => {
        const el = createTestElement('test-array-pop');
        const state = ReactiveState.create({ items: [1, 2, 3] });

        Elements.bind({
          'test-array-pop': () => state.items.join(',')
        });

        await waitFor(() => el.textContent === '1,2,3');

        state.items.pop();
        await waitFor(() => el.textContent === '1,2');
        assertEqual(el.textContent, '1,2');

        Elements.unbind('test-array-pop');
        removeTestElement('test-array-pop');
      });

      runner.it('should react to splice()', async () => {
        const el = createTestElement('test-array-splice');
        const state = ReactiveState.create({ items: [1, 2, 3, 4] });

        Elements.bind({
          'test-array-splice': () => state.items.join(',')
        });

        await waitFor(() => el.textContent === '1,2,3,4');

        state.items.splice(1, 2);
        await waitFor(() => el.textContent === '1,4');
        assertEqual(el.textContent, '1,4');

        Elements.unbind('test-array-splice');
        removeTestElement('test-array-splice');
      });

      runner.it('should react to array length changes', async () => {
        const el = createTestElement('test-array-length');
        const state = ReactiveState.create({ items: [1, 2, 3] });

        Elements.bind({
          'test-array-length': () => state.items.length
        });

        await waitFor(() => el.textContent === '3');

        state.items.push(4, 5);
        await waitFor(() => el.textContent === '5');
        assertEqual(el.textContent, '5');

        Elements.unbind('test-array-length');
        removeTestElement('test-array-length');
      });

      runner.it('should react to array element changes', async () => {
        const el = createTestElement('test-array-element');
        const state = ReactiveState.create({ items: [1, 2, 3] });

        Elements.bind({
          'test-array-element': () => state.items[1]
        });

        await waitFor(() => el.textContent === '2');

        state.items[1] = 20;
        await waitFor(() => el.textContent === '20');
        assertEqual(el.textContent, '20');

        Elements.unbind('test-array-element');
        removeTestElement('test-array-element');
      });
    });

    // 7. Untrack Tests
    runner.describe('Untracked Reads', () => {
      runner.it('should not track dependencies in untrack()', async () => {
        const el = createTestElement('test-untrack');
        const state = ReactiveState.create({ tracked: 1, untracked: 2 });
        let lastValue = '';

        Elements.bind({
          'test-untrack': () => {
            const tracked = state.tracked;
            const untracked = ReactiveState.untrack(() => state.untracked);
            lastValue = `${tracked},${untracked}`;
            return lastValue;
          }
        });

        await waitFor(() => el.textContent === '1,2');

        // Changing untracked should not trigger update
        state.untracked = 20;
        await new Promise(resolve => setTimeout(resolve, 50));
        assertEqual(el.textContent, '1,2');

        // Changing tracked should trigger update
        state.tracked = 10;
        await waitFor(() => el.textContent === '10,20');
        assertEqual(el.textContent, '10,20');

        Elements.unbind('test-untrack');
        removeTestElement('test-untrack');
      });
    });

    // 8. Pause/Resume Tests
    runner.describe('Pause/Resume Tracking', () => {
      runner.it('should pause and resume reactivity', async () => {
        const el = createTestElement('test-pause');
        const state = ReactiveState.create({ value: 0 });

        Elements.bind({
          'test-pause': () => state.value
        });

        await waitFor(() => el.textContent === '0');

        ReactiveState.pauseTracking();
        
        state.value = 1;
        state.value = 2;
        state.value = 3;
        
        await new Promise(resolve => setTimeout(resolve, 50));
        assertEqual(el.textContent, '0', 'Should not update while paused');

    ReactiveState.resumeTracking(true);
    await waitFor(() => el.textContent === '3');
    assertEqual(el.textContent, '3');

    Elements.unbind('test-pause');
    removeTestElement('test-pause');
  });

  runner.it('should accumulate updates while paused', async () => {
    const el = createTestElement('test-pause-accumulate');
    const state = ReactiveState.create({ a: 0, b: 0 });
    let updateCount = 0;

    Elements.bind({
      'test-pause-accumulate': () => {
        updateCount++;
        return `${state.a},${state.b}`;
      }
    });

    await waitFor(() => el.textContent === '0,0');
    const initialCount = updateCount;

    ReactiveState.pauseTracking();
    
    state.a = 1;
    state.b = 2;
    state.a = 3;
    state.b = 4;
    
    ReactiveState.resumeTracking(true);
    
    await waitFor(() => el.textContent === '3,4');
    
    // Should batch all paused updates
    assert(updateCount <= initialCount + 3, 'Should batch paused updates');

    Elements.unbind('test-pause-accumulate');
    removeTestElement('test-pause-accumulate');
  });
});

// 9. Collection Helper Tests
runner.describe('Collection Helpers', () => {
  runner.it('should create reactive collection', () => {
    const collection = ReactiveState.collection([1, 2, 3]);
    assertDeepEqual(collection.items, [1, 2, 3]);
  });

  runner.it('should add items with $add', async () => {
    const el = createTestElement('test-collection-add');
    const collection = ReactiveState.collection([1, 2]);

    Elements.bind({
      'test-collection-add': () => collection.items.length
    });

    await waitFor(() => el.textContent === '2');

    collection.$add(3);
    await waitFor(() => el.textContent === '3');
    assertEqual(el.textContent, '3');

    Elements.unbind('test-collection-add');
    removeTestElement('test-collection-add');
  });

  runner.it('should remove items with $remove', async () => {
    const el = createTestElement('test-collection-remove');
    const collection = ReactiveState.collection([1, 2, 3]);

    Elements.bind({
      'test-collection-remove': () => collection.items.join(',')
    });

    await waitFor(() => el.textContent === '1,2,3');

    collection.$remove(2);
    await waitFor(() => el.textContent === '1,3');
    assertEqual(el.textContent, '1,3');

    Elements.unbind('test-collection-remove');
    removeTestElement('test-collection-remove');
  });

  runner.it('should remove items with predicate', async () => {
    const el = createTestElement('test-collection-remove-pred');
    const collection = ReactiveState.collection([
      { id: 1, name: 'A' },
      { id: 2, name: 'B' },
      { id: 3, name: 'C' }
    ]);

    Elements.bind({
      'test-collection-remove-pred': () => collection.items.length
    });

    await waitFor(() => el.textContent === '3');

    collection.$remove(item => item.id === 2);
    await waitFor(() => el.textContent === '2');
    assertEqual(el.textContent, '2');

    Elements.unbind('test-collection-remove-pred');
    removeTestElement('test-collection-remove-pred');
  });

  runner.it('should update items with $update', async () => {
    const el = createTestElement('test-collection-update');
    const collection = ReactiveState.collection([
      { id: 1, name: 'A' },
      { id: 2, name: 'B' }
    ]);

    Elements.bind({
      'test-collection-update': () => collection.items[1].name
    });

    await waitFor(() => el.textContent === 'B');

    collection.$update(item => item.id === 2, { name: 'Updated' });
    await waitFor(() => el.textContent === 'Updated');
    assertEqual(el.textContent, 'Updated');

    Elements.unbind('test-collection-update');
    removeTestElement('test-collection-update');
  });

  runner.it('should clear items with $clear', async () => {
    const el = createTestElement('test-collection-clear');
    const collection = ReactiveState.collection([1, 2, 3]);

    Elements.bind({
      'test-collection-clear': () => collection.items.length
    });

    await waitFor(() => el.textContent === '3');

    collection.$clear();
    await waitFor(() => el.textContent === '0');
    assertEqual(el.textContent, '0');

    Elements.unbind('test-collection-clear');
    removeTestElement('test-collection-clear');
  });
});

// 10. Form Helper Tests
runner.describe('Form Helpers', () => {
  runner.it('should create reactive form', () => {
    const form = ReactiveState.form({ email: '', password: '' });
    assertEqual(form.values.email, '');
    assertEqual(form.values.password, '');
    assertDeepEqual(form.errors, {});
    assertDeepEqual(form.touched, {});
    assertEqual(form.isSubmitting, false);
  });

  runner.it('should set values with $setValue', async () => {
    const el = createTestElement('test-form-value', 'input');
    const form = ReactiveState.form({ username: '' });

    Elements.bind({
      'test-form-value': {
        value: () => form.values.username
      }
    });

    await waitFor(() => el.value === '');

    form.$setValue('username', 'john');
    await waitFor(() => el.value === 'john');
    assertEqual(el.value, 'john');
    assertEqual(form.touched.username, true);

    Elements.unbind('test-form-value');
    removeTestElement('test-form-value');
  });

  runner.it('should set errors with $setError', () => {
    const form = ReactiveState.form({ email: '' });
    
    form.$setError('email', 'Invalid email');
    assertEqual(form.errors.email, 'Invalid email');
    
    form.$setError('email', null);
    assertEqual(form.errors.email, undefined);
  });

  runner.it('should compute isValid', () => {
    const form = ReactiveState.form({ email: '' });
    
    assertEqual(form.isValid, true);
    
    form.$setError('email', 'Required');
    assertEqual(form.isValid, false);
    
    form.$setError('email', null);
    assertEqual(form.isValid, true);
  });

  runner.it('should compute isDirty', () => {
    const form = ReactiveState.form({ username: '' });
    
    assertEqual(form.isDirty, false);
    
    form.$setValue('username', 'test');
    assertEqual(form.isDirty, true);
  });

  runner.it('should reset form with $reset', () => {
    const form = ReactiveState.form({ email: 'test@example.com' });
    
    form.$setValue('email', 'changed@example.com');
    form.$setError('email', 'Error');
    form.isSubmitting = true;
    
    form.$reset();
    
    assertEqual(form.values.email, 'test@example.com');
    assertDeepEqual(form.errors, {});
    assertDeepEqual(form.touched, {});
    assertEqual(form.isSubmitting, false);
  });
});

// 11. Async Helper Tests
runner.describe('Async Helpers', () => {
  runner.it('should create reactive async state', () => {
    const asyncState = ReactiveState.async(null);
    assertEqual(asyncState.data, null);
    assertEqual(asyncState.loading, false);
    assertEqual(asyncState.error, null);
  });

  runner.it('should execute async function', async () => {
    const asyncState = ReactiveState.async(null);
    
    const result = await asyncState.$execute(async () => {
      await new Promise(resolve => setTimeout(resolve, 50));
      return 'success';
    });

    assertEqual(result, 'success');
    assertEqual(asyncState.data, 'success');
    assertEqual(asyncState.loading, false);
    assertEqual(asyncState.error, null);
  });

  runner.it('should set loading state', async () => {
    const el = createTestElement('test-async-loading');
    const asyncState = ReactiveState.async(null);

    Elements.bind({
      'test-async-loading': () => asyncState.loading ? 'Loading...' : 'Done'
    });

    await waitFor(() => el.textContent === 'Done');

    const promise = asyncState.$execute(async () => {
      await new Promise(resolve => setTimeout(resolve, 100));
      return 'data';
    });

    await waitFor(() => el.textContent === 'Loading...');
    assertEqual(el.textContent, 'Loading...');

    await promise;
    await waitFor(() => el.textContent === 'Done');
    assertEqual(el.textContent, 'Done');

    Elements.unbind('test-async-loading');
    removeTestElement('test-async-loading');
  });

  runner.it('should handle errors', async () => {
    const asyncState = ReactiveState.async(null);
    
    try {
      await asyncState.$execute(async () => {
        throw new Error('Test error');
      });
    } catch (e) {
      // Expected
    }

    assertEqual(asyncState.loading, false);
    assert(asyncState.error !== null);
    assertEqual(asyncState.error.message, 'Test error');
  });

  runner.it('should compute isSuccess', async () => {
    const asyncState = ReactiveState.async(null);
    
    assertEqual(asyncState.isSuccess, false);
    
    await asyncState.$execute(async () => 'data');
    
    assertEqual(asyncState.isSuccess, true);
  });

  runner.it('should compute isError', async () => {
    const asyncState = ReactiveState.async(null);
    
    assertEqual(asyncState.isError, false);
    
    try {
      await asyncState.$execute(async () => {
        throw new Error('Error');
      });
    } catch (e) {
      // Expected
    }
    
    assertEqual(asyncState.isError, true);
  });

  runner.it('should reset async state', async () => {
    const asyncState = ReactiveState.async('initial');
    
    await asyncState.$execute(async () => 'loaded');
    assertEqual(asyncState.data, 'loaded');
    
    asyncState.$reset();
    assertEqual(asyncState.data, 'initial');
    assertEqual(asyncState.loading, false);
    assertEqual(asyncState.error, null);
  });
});

// 12. Notify Tests
runner.describe('Manual Notifications', () => {
  runner.it('should manually trigger updates with $notify', async () => {
    const el = createTestElement('test-notify');
    const state = ReactiveState.create({ counter: 0 });
    let renderCount = 0;

    Elements.bind({
      'test-notify': () => {
        renderCount++;
        return state.counter;
      }
    });

    await waitFor(() => el.textContent === '0');
    const initialRender = renderCount;

    // Change value without triggering setter
    state.$raw.counter = 5;
    await new Promise(resolve => setTimeout(resolve, 50));
    assertEqual(renderCount, initialRender, 'Should not update yet');

    // Manually notify
    state.$notify('counter');
    await waitFor(() => el.textContent === '5');
    assertEqual(el.textContent, '5');

    Elements.unbind('test-notify');
    removeTestElement('test-notify');
  });

  runner.it('should notify all dependencies without key', async () => {
    const el = createTestElement('test-notify-all');
    const state = ReactiveState.create({ a: 1, b: 2 });

    Elements.bind({
      'test-notify-all': () => `${state.a},${state.b}`
    });

    await waitFor(() => el.textContent === '1,2');

    // Change raw values
    state.$raw.a = 10;
    state.$raw.b = 20;

    // Notify all
    state.$notify();
    await waitFor(() => el.textContent === '10,20');
    assertEqual(el.textContent, '10,20');

    Elements.unbind('test-notify-all');
    removeTestElement('test-notify-all');
  });
});

// 13. Cleanup Tests
runner.describe('Cleanup & Memory Management', () => {
  runner.it('should cleanup bindings when element is removed', async () => {
    const el = createTestElement('test-cleanup');
    const state = ReactiveState.create({ value: 'test' });

    Elements.bind({
      'test-cleanup': () => state.value
    });

    await waitFor(() => el.textContent === 'test');

    const info = ReactiveState.debug.getElementBindingInfo(el);
    assert(info.count > 0, 'Should have bindings');

    el.remove();
    await new Promise(resolve => setTimeout(resolve, 100));

    const infoAfter = ReactiveState.debug.getElementBindingInfo(el);
    assertEqual(infoAfter.count, 0, 'Should cleanup bindings');
  });

  runner.it('should unbind elements manually', async () => {
    const el = createTestElement('test-unbind');
    const state = ReactiveState.create({ value: 'test' });

    Elements.bind({
      'test-unbind': () => state.value
    });

    await waitFor(() => el.textContent === 'test');

    Elements.unbind('test-unbind');

    state.value = 'changed';
    await new Promise(resolve => setTimeout(resolve, 50));

    assertEqual(el.textContent, 'test', 'Should not update after unbind');

    removeTestElement('test-unbind');
  });
});

// 14. Selector Binding Tests
runner.describe('Selector Bindings', () => {
  runner.it('should bind with querySelector', async () => {
    const el = createTestElement('test-query');
    el.setAttribute('data-test', 'selector');
    const state = ReactiveState.create({ text: 'Query' });

    Selector.query.bind({
      '[data-test="selector"]': () => state.text
    });

    await waitFor(() => el.textContent === 'Query');
    assertEqual(el.textContent, 'Query');

    state.text = 'Updated';
    await waitFor(() => el.textContent === 'Updated');
    assertEqual(el.textContent, 'Updated');

    Selector.query.unbind('[data-test="selector"]');
    removeTestElement('test-query');
  });

  runner.it('should bind with querySelectorAll', async () => {
    const el1 = createTestElement('test-query-all-1');
    const el2 = createTestElement('test-query-all-2');
    el1.className = 'query-all-test';
    el2.className = 'query-all-test';

    const state = ReactiveState.create({ text: 'All' });

    Selector.queryAll.bind({
      '.query-all-test': () => state.text
    });

    await waitFor(() => el1.textContent === 'All' && el2.textContent === 'All');
    assertEqual(el1.textContent, 'All');
    assertEqual(el2.textContent, 'All');

    state.text = 'Changed';
    await waitFor(() => el1.textContent === 'Changed' && el2.textContent === 'Changed');
    assertEqual(el1.textContent, 'Changed');
    assertEqual(el2.textContent, 'Changed');

    Selector.queryAll.unbind('.query-all-test');
    removeTestElement('test-query-all-1');
    removeTestElement('test-query-all-2');
  });
});

// 15. Complex Scenarios
runner.describe('Complex Scenarios', () => {
  runner.it('should handle deeply nested reactivity', async () => {
    const el = createTestElement('test-deep-nested');
    const state = ReactiveState.create({
      user: {
        profile: {
          address: {
            city: 'New York'
          }
        }
      }
    });

    Elements.bind({
      'test-deep-nested': () => state.user.profile.address.city
    });

    await waitFor(() => el.textContent === 'New York');

    state.user.profile.address.city = 'Los Angeles';
    await waitFor(() => el.textContent === 'Los Angeles');
    assertEqual(el.textContent, 'Los Angeles');

    Elements.unbind('test-deep-nested');
    removeTestElement('test-deep-nested');
  });

  runner.it('should handle array of objects', async () => {
    const el = createTestElement('test-array-objects');
    const state = ReactiveState.create({
      users: [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' }
      ]
    });

    Elements.bind({
      'test-array-objects': () => state.users.map(u => u.name).join(', ')
    });

    await waitFor(() => el.textContent === 'Alice, Bob');

    state.users[0].name = 'Alice Updated';
    await waitFor(() => el.textContent === 'Alice Updated, Bob');
    assertEqual(el.textContent, 'Alice Updated, Bob');

    state.users.push({ id: 3, name: 'Charlie' });
    await waitFor(() => el.textContent === 'Alice Updated, Bob, Charlie');
    assertEqual(el.textContent, 'Alice Updated, Bob, Charlie');

    Elements.unbind('test-array-objects');
    removeTestElement('test-array-objects');
  });

  runner.it('should handle multiple bindings on same element', async () => {
    const el = createTestElement('test-multiple-bindings', 'div');
    const state = ReactiveState.create({ 
      text: 'Hello',
      color: 'red',
      visible: true
    });

    Elements.bind({
      'test-multiple-bindings': {
        textContent: () => state.text,
        style: () => ({ color: state.color }),
        classList: () => ({ hidden: !state.visible })
      }
    });

    await waitFor(() => el.textContent === 'Hello');
    assertEqual(el.style.color, 'red');
    assert(!el.classList.contains('hidden'));

    state.$batch(function() {
      this.text = 'World';
      this.color = 'blue';
      this.visible = false;
    });

    await waitFor(() => el.textContent === 'World');
    assertEqual(el.textContent, 'World');
    assertEqual(el.style.color, 'blue');
    assert(el.classList.contains('hidden'));

    Elements.unbind('test-multiple-bindings');
    removeTestElement('test-multiple-bindings');
  });

  runner.it('should handle computed properties with watchers', async () => {
    const state = ReactiveState.create({ 
      firstName: 'John',
      lastName: 'Doe'
    });

    state.$computed('fullName', function() {
      return `${this.firstName} ${this.lastName}`;
    });

    let watchedValue = '';
    const unwatch = state.$watch('fullName', (newVal) => {
      watchedValue = newVal;
    });

    state.firstName = 'Jane';
    await waitFor(() => watchedValue === 'Jane Doe');
    assertEqual(watchedValue, 'Jane Doe');

    state.lastName = 'Smith';
    await waitFor(() => watchedValue === 'Jane Smith');
    assertEqual(watchedValue, 'Jane Smith');

    unwatch();
  });

  runner.it('should handle conditional rendering', async () => {
    const el = createTestElement('test-conditional');
    const state = ReactiveState.create({ 
      show: true,
      message: 'Visible'
    });

    Elements.bind({
      'test-conditional': () => state.show ? state.message : ''
    });

    await waitFor(() => el.textContent === 'Visible');

    state.show = false;
    await waitFor(() => el.textContent === '');
    assertEqual(el.textContent, '');

    // Changing message while hidden shouldn't trigger update
    state.message = 'Changed';
    await new Promise(resolve => setTimeout(resolve, 50));
    assertEqual(el.textContent, '');

    state.show = true;
    await waitFor(() => el.textContent === 'Changed');
    assertEqual(el.textContent, 'Changed');

    Elements.unbind('test-conditional');
    removeTestElement('test-conditional');
  });
});

// 16. Debug Utilities Tests
runner.describe('Debug Utilities', () => {
  runner.it('should get state dependencies', () => {
    const el = createTestElement('test-debug-deps');
    const state = ReactiveState.create({ a: 1, b: 2 });

    Elements.bind({
      'test-debug-deps': () => state.a + state.b
    });

    const deps = ReactiveState.debug.getStateDependencies(state);
    assert(deps !== null);
    assert(deps.a !== undefined);
    assert(deps.b !== undefined);

    Elements.unbind('test-debug-deps');
    removeTestElement('test-debug-deps');
  });

  runner.it('should get element binding info', () => {
    const el = createTestElement('test-debug-element');
    const state = ReactiveState.create({ value: 'test' });

    Elements.bind({
      'test-debug-element': () => state.value
    });

    const info = ReactiveState.debug.getElementBindingInfo(el);
    assert(info.count > 0);
    assert(Array.isArray(info.bindings));

    Elements.unbind('test-debug-element');
    removeTestElement('test-debug-element');
  });

  runner.it('should get reactive stats', () => {
    const stats = ReactiveState.debug.getReactiveStats();
    assert(typeof stats.pendingUpdates === 'number');
    assert(typeof stats.batchDepth === 'number');
    assert(typeof stats.isFlushing === 'boolean');
    assert(typeof stats.isPaused === 'boolean');
  });

  runner.it('should debug state structure', () => {
    const state = ReactiveState.create({ test: 'value' });
    
    // Should not throw
    state.$debug('Test State');
    
    // Check console was called (can't easily test without mocking)
    assert(true);
  });
});

// 17. Edge Cases
runner.describe('Edge Cases', () => {
  runner.it('should handle null and undefined values', async () => {
    const el = createTestElement('test-null');
    const state = ReactiveState.create({ value: 'test' });

    Elements.bind({
      'test-null': () => state.value
    });

    await waitFor(() => el.textContent === 'test');

    state.value = null;
    await waitFor(() => el.textContent === '');
    assertEqual(el.textContent, '');

    state.value = undefined;
    await waitFor(() => el.textContent === '');
    assertEqual(el.textContent, '');

    Elements.unbind('test-null');
    removeTestElement('test-null');
  });

  runner.it('should handle boolean values', async () => {
    const el = createTestElement('test-boolean', 'input');
    el.type = 'checkbox';
    const state = ReactiveState.create({ checked: false });

    Elements.bind({
      'test-boolean': {
        checked: () => state.checked
      }
    });

    await waitFor(() => el.checked === false);

    state.checked = true;
    await waitFor(() => el.checked === true);
    assert(el.checked);

    Elements.unbind('test-boolean');
    removeTestElement('test-boolean');
  });

  runner.it('should handle number values', async () => {
    const el = createTestElement('test-number', 'input');
    el.type = 'number';
    const state = ReactiveState.create({ count: 0 });

    Elements.bind({
      'test-number': {
        value: () => state.count
      }
    });

    await waitFor(() => el.value === '0');

    state.count = 42;
    await waitFor(() => el.value === '42');
    assertEqual(el.value, '42');

    Elements.unbind('test-number');
    removeTestElement('test-number');
  });

  runner.it('should handle empty objects and arrays', async () => {
    const el = createTestElement('test-empty');
    const state = ReactiveState.create({ 
      obj: {},
      arr: []
    });

    Elements.bind({
      'test-empty': () => `${Object.keys(state.obj).length},${state.arr.length}`
    });

    await waitFor(() => el.textContent === '0,0');
    assertEqual(el.textContent, '0,0');

    state.obj.key = 'value';
    state.arr.push('item');

    await waitFor(() => el.textContent === '1,1');
    assertEqual(el.textContent, '1,1');

    Elements.unbind('test-empty');
    removeTestElement('test-empty');
  });

  runner.it('should handle rapid successive updates', async () => {
    const el = createTestElement('test-rapid');
    const state = ReactiveState.create({ counter: 0 });

    Elements.bind({
      'test-rapid': () => state.counter
    });

    await waitFor(() => el.textContent === '0');

    // Rapid updates
    for (let i = 1; i <= 100; i++) {
      state.counter = i;
    }

    await waitFor(() => el.textContent === '100');
    assertEqual(el.textContent, '100');

    Elements.unbind('test-rapid');
    removeTestElement('test-rapid');
  });

  runner.it('should handle circular object references in raw values', () => {
    const obj = { name: 'test' };
    obj.self = obj;

    const state = ReactiveState.create(obj);
    
    // Should not throw
    assert(ReactiveState.isReactive(state));
    assertEqual(state.name, 'test');
  });
});

// 18. Performance Tests
runner.describe('Performance', () => {
  runner.it('should handle large arrays efficiently', async () => {
    const el = createTestElement('test-large-array');
    const largeArray = Array.from({ length: 1000 }, (_, i) => i);
    const state = ReactiveState.create({ items: largeArray });

    const startTime = performance.now();

    Elements.bind({
      'test-large-array': () => state.items.length
    });

    await waitFor(() => el.textContent === '1000');

    state.items.push(1000);
    await waitFor(() => el.textContent === '1001');

    const duration = performance.now() - startTime;
    
    // Should complete in reasonable time (less than 1 second)
    assert(duration < 1000, 'Should handle large arrays efficiently');

    Elements.unbind('test-large-array');
    removeTestElement('test-large-array');
  });

  runner.it('should handle many bindings efficiently', async () => {
    const elements = [];
    const state = ReactiveState.create({ value: 'shared' });

    // Create 50 elements
    for (let i = 0; i < 50; i++) {
      const el = createTestElement(`test-many-${i}`);
      elements.push(el);
    }

    const startTime = performance.now();

    // Bind all elements
    const bindings = {};
    elements.forEach(el => {
      bindings[el.id] = () => state.value;
    });
    Elements.bind(bindings);

    await waitFor(() => elements.every(el => el.textContent === 'shared'));

    state.value = 'updated';
    await waitFor(() => elements.every(el => el.textContent === 'updated'));

    const duration = performance.now() - startTime;
    
    // Should complete in reasonable time
    assert(duration < 2000, 'Should handle many bindings efficiently');

    // Cleanup
    elements.forEach(el => {
      Elements.unbind(el.id);
      el.remove();
    });
  });
});

// 19. Configuration Tests
runner.describe('Configuration', () => {
  runner.it('should configure maxDependencyDepth', () => {
    ReactiveState.configure({ maxDependencyDepth: 50 });
    
    // Create deeply nested binding (would warn if depth exceeded)
    const state = ReactiveState.create({ value: 0 });
    let depth = 0;
    
    const createNestedBinding = () => {
      if (depth++ > 60) return;
      const el = createTestElement(`test-depth-${depth}`);
      Elements.bind({
        [`test-depth-${depth}`]: () => {
          createNestedBinding();
          return state.value;
        }
      });
    };

    // Should not crash (though may warn)
    try {
      createNestedBinding();
      assert(true);
    } catch (e) {
      assert(false, 'Should handle depth configuration');
    }

    // Cleanup
    for (let i = 1; i <= depth; i++) {
      const el = document.getElementById(`test-depth-${i}`);
      if (el) {
        Elements.unbind(`test-depth-${i}`);
        el.remove();
      }
    }

    // Reset
    ReactiveState.configure({ maxDependencyDepth: 100 });
  });

  runner.it('should enable/disable debug mode', () => {
    ReactiveState.debug.setDebugMode(true);
    const stats = ReactiveState.debug.getReactiveStats();
    assert(typeof stats === 'object');
    
    ReactiveState.debug.setDebugMode(false);
  });

  runner.it('should set custom error handler', async () => {
    let capturedError = null;
    
    ReactiveState.configure({
      errorHandler: (error, context, data) => {
        capturedError = { error, context, data };
      }
    });

    const el = createTestElement('test-error-handler');
    const state = ReactiveState.create({ value: 'test' });

    Elements.bind({
      'test-error-handler': () => {
        if (state.value === 'error') {
          throw new Error('Test error');
        }
        return state.value;
      }
    });

    await waitFor(() => el.textContent === 'test');

    state.value = 'error';
    await new Promise(resolve => setTimeout(resolve, 100));

    assert(capturedError !== null, 'Should capture error');
    assertEqual(capturedError.error.message, 'Test error');

    // Reset
    ReactiveState.configure({ errorHandler: null });
    Elements.unbind('test-error-handler');
    removeTestElement('test-error-handler');
  });
});

// Global test runner function
async function runAllTests() {
  const button = document.querySelector('.run-tests-btn');
  button.disabled = true;
button.textContent = 'Running Tests...';
await runner.runAll();
  
  button.disabled = false;
  button.textContent = 'Run All Tests Again';
  
  // Show summary notification
  const { passed, failed, total } = runner.results;
  const message = failed === 0 
    ? `✅ All ${total} tests passed!` 
    : `⚠️ ${passed}/${total} tests passed, ${failed} failed`;
  
  console.log(message);
}

// Make it globally available
window.runAllTests = runAllTests;

// Auto-run on load (optional)
// window.addEventListener('load', runAllTests);
</script>
</body>
</html>